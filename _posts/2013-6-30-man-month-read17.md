---
layout : post
category : lessons
tags : [读书, 人月神话]
title : 人月神话--再论没有银弹
---


<div><ul>
	<li><div style="background-color:#cc0000;">
<a href="/lessons/2013/01/30/man-month-read00/" title="返回《人月神话》目录"><font color="#FFFF00" >返回《人月神话》目录</font></a>
<a href="/lessons/2013/05/29/man-month-read16/" title="上一篇">上一篇</a></div>
		<ul>
	<li><div>序</div>
		<ul>
	<li><div>那些想看到完美方案的人，其实在心底里就认为它们以前不存在，以后也不可能出现</div></li></ul></li>
	<li><div>含糊的表达将会导致误解 </div>
		<ul>
	<li><div>次要（Acciden t ）</div>
		<ul>
	<li><div>创造性活动包括（1 ）概念性结构的形式规格 化，（2 ）使用现实的介质来实现，（3 ）在实际的使用中，与用户交互 。在软件开发中，我 称为“必要（essence）”的部分是构思这些概念上的结构；我称为“次要（accid ent ）”的 部分指它的实现过程。</div></li></ul></li>
	<li><div>现实问题</div>
		<ul>
	<li><div>在我看来，开发的次要或者表达部分现在已经下降到整个工作的一半或一半以下。</div></li>
	<li><div>《没有银弹》无可争辩地指出，如果开发的次要部分少于整个工作的9/10，那么即使 不占用任何时间（除非出现奇迹），也不会给生产率带来数量级的提高。因此，必须着手解 决开发的根本问题。</div></li>
	<li><div>他们发现动机因素可以提高生产率。另一方面，环境和次要因素， 无论起到多么积极的作用，仍无法提高生产率。但是在产生负面影响时，它们会使生产率降 低。</div></li></ul></li>
	<li><div>因为是根本困难所以没有希望</div>
		<ul>
	<li><div>重用和交互的构件开发是解决软件根本困 难的一种方法</div></li>
	<li><div>而我认为根本困难是固有的概念复杂性。作为本质 上的困难，构思软件概念性的结构本身就有复杂性、一致性、可变性及不可见性的特点。</div></li></ul></li>
	<li><div>复杂性是层次化的</div>
		<ul>
	<li><div>就我的经验而言，在系统工作中所遇到的大多数困难是组织结构上的一些失误征兆。 试图为这些现实建模，建立同等复杂的程序，实际上是隐藏，而不是解决这些杂乱无章的情 况</div></li>
	<li><div>系统复杂性是无数细节的函数</div></li>
	<li><div>而在更高的级别开发（发展）软件，使用其他人的成果，或者 重用自己的程序——都能避免面对整个层次的复杂性。</div></li>
	<li><div>它倡导向软件系统增加必要的复 杂性：</div>
		<ul>
	<li><div>层次化，通过分层的模块或者对象。</div></li>
	<li><div>增量化，从而系统可以持续地运行。</div></li></ul></li></ul></li></ul></li>
	<li><div>Hare l 的分析</div>
		<ul>
	<li><div>悲观主义 vs.  乐观主义 vs . 现实主义</div>
		<ul>
	<li><div>我的从业背景是程序员，乐观主义是这个行业的职业病</div></li>
	<li><div>软件的特性本身导致了不大可能有任何的银弹</div></li>
	<li><div>我们太过倾向于遵循我们自己的乐观主义（或者是发掘我们出资人的乐观主义）。我们 太喜欢忽视真理的声音，而去听从万灵药贩卖者的诱惑</div></li></ul></li></ul></li>
	<li><div>Jone的观点——质量带来生产率</div>
		<ul>
	<li><div>关注质量，生产率自然会随着提高。 他认为，很多代价高昂的后续项目投入了大量的时间和精力来寻找和修复规格说明中、 设计和实现上的错误。他提供的数据显示了缺乏系统化质量控制和进度灾难之间的密切关 系。我认同这些数据。不过，Boehm 指出，如果一味追求完美质量，生产率会像IBM 的航天 软件一样再次下降。</div></li></ul></li>
	<li><div>面向对象编程——这颗铜质子弹可以吗</div>
		<ul>
	<li><div>使用更大的零件来构建</div>
		<ul>
	<li><div>面向对象编程的第一个特征是，它强制的模块化和清晰的接 口。</div></li>
	<li><div>其次，它强调了封装，即外界无法看到组件的内部结构；它还强调了继承和层次化类结构以及虚函数。</div></li>
	<li><div>面向对象还强调了强抽象数据类型化，它确保某种特定的数据类型只能由它 自身的相应函数来操作。 </div></li></ul></li>
	<li><div>面向对象技术为什么发展缓慢</div>
		<ul>
	<li><div>问题是O-O程序员经历了很多错综复杂混乱的应用，他们所关注的是低层次，而不是 高层次的抽象。</div></li>
	<li><div>主张一种解决软件不能满足要求的方法，即通过客户的参 与和协作来提高脑力劳动的规模。</div></li>
	<li><div>我们可以用任何工具写出优质或低劣的代码。除非我们给人们讲解如何设计，否则语言所起 的作用非常小。</div></li></ul></li></ul></li>
	<li><div>重用的情况怎样</div>
		<ul>
	<li><div>写在前面</div>
		<ul>
	<li><div>解决软件构建根本困难的最佳方法是不进行任何开发。</div></li>
	<li><div>类的容易重用和通过继承方便地定制是面向对象 技术最吸引人的地方。</div></li>
	<li><div>大多数有丰富经验的程序员拥有自己的私人开发库，可以使他们使用大约30％的重用 代码来开发软件。公司级别的重用能提供70％的重用代码量，它需要特殊的开发库和管理 支持。</div></li></ul></li>
	<li><div>现在公司级别的重用情况如何</div>
		<ul>
	<li><div>重用是一件说起来容易，做起来难的事情。它同时需要良好的设计和文档。即使我们看到了并不十分常见的优秀设计，但如果没有好的文档，我们也不会看到能重用的构件。</div></li></ul></li></ul></li>
	<li><div>学习大量的词汇——对软件重用的一个可预见，但还没有被预言的问题 </div>
		<ul>
	<li><div>1</div>
		<ul>
	<li><div>高级语言有更广泛的词汇量、更复杂的语法以及更 加丰富的语义。</div></li>
	<li><div>任何使用类库编程的人员必须学习其成员的语法（外部接 口）和语义（详细的功能行为）</div></li>
	<li><div>一些经验教训 是显而易见的</div>
		<ul>
	<li><div>人们在上下文中学习，所以我们需要出版一些复合产品的例子，而不仅仅是零部件 的库。</div></li>
	<li><div>人们只会记忆背诵单词。语法和语义是在上下文中，通过使用逐渐地学习。</div></li>
	<li><div>人们根据语义上的分类对词汇组合规则进行分组，而不是通过比较对象子集</div></li></ul></li></ul></li></ul></li>
	<li><div>子弹的本质——形势没有发生改变</div>
		<ul>
	<li><div>复杂性是我们这个行业的属性，而且复杂性是我们主要的 限制。</div></li></ul></li></ul></li></ul>

				<div style="background-color:#ff0000;"><a href="/lessons/2013/06/30/man-month-read18/" title="下一篇">下一篇</a></div>